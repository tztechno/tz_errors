### 問題の理解

まず、問題の内容を正確に理解しましょう。

**良い整数の定義**: 正の整数 \( X \) が「良い整数」であるとは、正の整数の組 \( (a, b) \) を用いて \( X = 2^a \times b^2 \) と書けるとき、かつそのときに限ります。ここで、\( a \) と \( b \) は正の整数です。

**例**: \( 400 = 2^2 \times 10^2 \) なので、400は良い整数です。

**問題**: 正の整数 \( N \) が与えられたとき、\( 1 \) 以上 \( N \) 以下の良い整数の個数を求めてください。

### 良い整数の性質を探る

良い整数 \( X \) は \( X = 2^a \times b^2 \) と表せます。この形から、\( X \) は「2の冪乗」と「ある整数の平方」の積であることがわかります。

ここで、\( b \) は任意の正の整数ですが、\( b \) が偶数の場合と奇数の場合で \( X \) の性質がどう変わるかを考えてみます。

#### ケース1: \( b \) が奇数の場合

\( b \) が奇数だとすると、\( b^2 \) も奇数です。したがって、\( X = 2^a \times \text{奇数} \) となります。つまり、\( X \) は2で \( a \) 回割り切れる奇数を含む数です。

例:
- \( b = 1 \): \( X = 2^a \times 1^2 = 2^a \) → \( 2, 4, 8, 16, \ldots \)
- \( b = 3 \): \( X = 2^a \times 9 \) → \( 18, 36, 72, 144, \ldots \)

#### ケース2: \( b \) が偶数の場合

\( b \) が偶数だとすると、\( b = 2 \times k \) （\( k \) は正の整数）と書けます。すると、

\( X = 2^a \times b^2 = 2^a \times (2k)^2 = 2^a \times 4k^2 = 2^{a+2} \times k^2 \)

これは、\( b \) が偶数の場合、\( X \) はより高い2の冪乗を含む形になります。しかし、この形は \( a \) を調整することで、\( b \) が奇数の場合の表現と重複する可能性があります。

例:
- \( b = 2 \), \( a = 1 \): \( X = 2^1 \times 4 = 8 \)
  これは \( b = 1 \), \( a = 3 \): \( X = 2^3 \times 1 = 8 \) と同じです。

このことから、\( b \) が偶数の場合の表現は、\( b \) が奇数の場合の表現と重複する可能性があるため、重複を避けるために \( b \) は奇数として考えても問題ないかもしれません。

### 良い整数の一意な表現

\( X \) を \( 2^a \times b^2 \) と表すとき、\( b \) を平方因子を含まない（つまり、平方数で割り切れない）ように選ぶことができます。これは、\( b \) が平方因子を持つ場合、それを \( a \) に吸収させることができるからです。

具体的には、\( b \) を square-free（平方因子を持たない）な正の整数とすると、すべての良い整数は一意に \( X = 2^a \times b^2 \) （\( b \) は square-free）と表せます。

しかし、この問題では個数を数えることが目的なので、必ずしも一意性を気にする必要はありません。むしろ、すべての良い整数を重複なく数える方法を考える必要があります。

### 良い整数の列挙

良い整数を小さい順に列挙してみましょう：

1. \( b = 1 \):
   - \( a = 1 \): \( X = 2 \times 1 = 2 \)
   - \( a = 2 \): \( X = 4 \times 1 = 4 \)
   - \( a = 3 \): \( X = 8 \times 1 = 8 \)
   - \( \ldots \)
   - \( 2^a \leq N \) となるまで。

2. \( b = 2 \):
   - \( b = 2 \) は偶数なので、\( b = 2 \times 1 \), \( k = 1 \)
   - \( X = 2^a \times 4 = 2^{a+2} \times 1^2 \)
   - これは \( b = 1 \), \( a' = a + 2 \) と同じ形なので、新しい良い整数は生成しません。

3. \( b = 3 \):
   - \( X = 2^a \times 9 \)
   - \( a = 1 \): \( 2 \times 9 = 18 \)
   - \( a = 2 \): \( 4 \times 9 = 36 \)
   - \( a = 3 \): \( 8 \times 9 = 72 \)
   - \( \ldots \)

4. \( b = 4 \):
   - \( b = 4 = 2^2 \), \( b^2 = 16 \)
   - \( X = 2^a \times 16 = 2^{a+4} \times 1^2 \)
   - これも \( b = 1 \), \( a' = a + 4 \) と同じ。

この観察から、\( b \) が平方数を含む場合（つまり、\( b \) が square-free でない場合）、その表現は \( b \) を square-free にした場合と重複することがわかります。したがって、良い整数を重複なく数えるためには、\( b \) を square-free な正の整数として選べばよいです。

### Square-free な数

Square-free な数とは、1以外の平方数で割り切れない正の整数のことです。つまり、素因数分解したときにすべての素数の指数が1以下の数です。

例: 1, 2, 3, 5, 6, 7, 10, 11, 13, 14, 15, ...

### 良い整数の個数の計算方法

良い整数 \( X = 2^a \times b^2 \) で \( X \leq N \) となるものを数えるには、以下の手順を踏みます：

1. \( b \) を square-free な正の整数とする。
2. 各 \( b \) に対して、\( 2^a \times b^2 \leq N \) となる最大の \( a \) を見つける。
   - \( a \) は \( a \geq 1 \) の整数なので、\( 2^a \leq \frac{N}{b^2} \) となる最大の \( a \)。
   - \( a_{\text{max}} = \lfloor \log_2 \left( \frac{N}{b^2} \right) \rfloor \) （ただし、\( \frac{N}{b^2} \geq 2 \)）
   - \( \frac{N}{b^2} < 2 \) のときは、\( a \) は存在しない（\( b^2 > N/2 \)）。
3. 各 \( b \) に対して、\( a \) の取り得る値の個数は \( \lfloor \log_2 \left( \frac{N}{b^2} \right) \rfloor \) （\( \frac{N}{b^2} \geq 2 \) の場合）または 0 （それ以外）。
   - 実際には、\( a \geq 1 \) なので、\( \frac{N}{b^2} \geq 2 \) が必要。
   - \( a \) の個数は \( \lfloor \log_2 \left( \frac{N}{b^2} \right) \rfloor \) （\( \geq 1 \) の場合）。
   - つまり、\( a \) は 1 から \( \lfloor \log_2 \left( \frac{N}{b^2} \right) \rfloor \) までの整数を取れるので、個数は \( \lfloor \log_2 \left( \frac{N}{b^2} \right) \rfloor \)。

しかし、\( a \) は正の整数なので、\( 2^a \times b^2 \leq N \) を満たす \( a \) の最大値は \( \lfloor \log_2 \left( \frac{N}{b^2} \right) \rfloor \) で、\( a \) の取り得る値の個数はこの値が 1 以上の場合に \( \lfloor \log_2 \left( \frac{N}{b^2} \right) \rfloor \) 個です。

ただし、\( \frac{N}{b^2} < 2 \) のときは \( a \geq 1 \) を満たす \( a \) は存在しないので、その \( b \) に対しては良い整数はありません。

したがって、良い整数の個数は：

\[ \sum_{\substack{b \text{ is square-free} \\ b^2 \leq N/2}} \left\lfloor \log_2 \left( \frac{N}{b^2} \right) \right\rfloor \]

さらに、\( b \) が square-free で \( b^2 \leq N/2 \) を満たす範囲で \( b \) を動かせばよいです。

### アルゴリズムの手順

具体的なアルゴリズムは以下のようになります：

1. \( b_{\text{max}} = \lfloor \sqrt{N/2} \rfloor \) を計算する。なぜなら、\( b^2 \leq N/2 \) より \( b \leq \sqrt{N/2} \)。
2. \( b \) を 1 から \( b_{\text{max}} \) まで動かし、各 \( b \) が square-free かどうかをチェックする。
   - \( b \) が square-free でない場合はスキップ。
   - \( b \) が square-free の場合：
     - \( a_{\text{max}} = \lfloor \log_2 (N / b^2) \rfloor \) を計算。
     - \( a_{\text{max}} \geq 1 \) の場合、\( a \) の取り得る値の個数は \( a_{\text{max}} \) 個。
     - これを総和に加算。
3. 最終的な総和が良い整数の個数。

### Square-free のチェック方法

ある数 \( b \) が square-free かどうかをチェックするには、\( b \) を素因数分解し、すべての素数の指数が1以下であることを確認します。より効率的には、\( b \) を割り切る平方数があるかどうかを調べます。つまり、\( d^2 \) で \( b \) を割り切る \( d \geq 2 \) が存在しないことを確認します。

### 具体例で確認

例として \( N = 100 \) の場合を考えます。

1. \( b_{\text{max}} = \lfloor \sqrt{100 / 2} \rfloor = \lfloor \sqrt{50} \rfloor = 7 \) （\( 7^2 = 49 \leq 50 \), \( 8^2 = 64 > 50 \)）
2. \( b \) を 1 から 7 まで動かし、square-free な \( b \) を選ぶ：
   - \( b = 1 \): square-free
     - \( \frac{100}{1} = 100 \), \( \log_2 100 \approx 6.644 \), \( a_{\text{max}} = 6 \)
     - \( a = 1 \) to \( 6 \): \( X = 2, 4, 8, 16, 32, 64 \)
   - \( b = 2 \): square-free (2 is prime)
     - \( \frac{100}{4} = 25 \), \( \log_2 25 \approx 4.644 \), \( a_{\text{max}} = 4 \)
     - \( a = 1 \) to \( 4 \): \( X = 2 \times 4 = 8 \), \( 4 \times 4 = 16 \), \( 8 \times 4 = 32 \), \( 16 \times 4 = 64 \)
     - しかし、これらの \( X \) は \( b = 1 \) のときの \( X \) と重複している（8, 16, 32, 64）。したがって、この方法では重複が生じる。
   - ここで、\( b \) が偶数の場合、\( b \) を square-free に分解する必要がある。つまり、\( b \) が square-free でない場合はスキップするべき。
   - 実際には、\( b \) を square-free な奇数に限定する必要があるかもしれない。

このように、\( b \) を square-free な奇数に限定することで、重複を避けることができます。なぜなら、\( b \) が偶数の場合、\( b = 2 \times k \) とすると、\( X = 2^a \times b^2 = 2^{a+2} \times k^2 \) となり、これは \( b' = k \), \( a' = a + 2 \) と同じ形になるからです。

したがって、\( b \) は square-free な奇数として選ぶことで、すべての良い整数を重複なく列挙できます。

### 修正したアルゴリズム

1. \( b \) を square-free な正の奇数とする。
2. 各 \( b \) に対して、\( 2^a \times b^2 \leq N \) となる \( a \geq 1 \) の個数を求める。
   - \( a_{\text{max}} = \lfloor \log_2 (N / b^2) \rfloor \)
   - \( a \) の個数は \( \max(0, a_{\text{max}}) \) （\( a \geq 1 \) なので）
3. すべての square-free な奇数 \( b \) に対して、この個数を合計する。

### \( N = 100 \) での再計算

square-free な奇数 \( b \leq \lfloor \sqrt{100 / 2} \rfloor = 7 \):

square-free な奇数: 1, 3, 5, 7

- \( b = 1 \):
  - \( \frac{100}{1} = 100 \), \( \log_2 100 \approx 6.644 \), \( a_{\text{max}} = 6 \)
  - \( a = 1 \) to \( 6 \): \( X = 2, 4, 8, 16, 32, 64 \)
  - 個数: 6
- \( b = 3 \):
  - \( \frac{100}{9} \approx 11.11 \), \( \log_2 11.11 \approx 3.47 \), \( a_{\text{max}} = 3 \)
  - \( a = 1 \) to \( 3 \): \( X = 2 \times 9 = 18 \), \( 4 \times 9 = 36 \), \( 8 \times 9 = 72 \)
  - 個数: 3
- \( b = 5 \):
  - \( \frac{100}{25} = 4 \), \( \log_2 4 = 2 \), \( a_{\text{max}} = 2 \)
  - \( a = 1 \) to \( 2 \): \( X = 2 \times 25 = 50 \), \( 4 \times 25 = 100 \)
  - 個数: 2
- \( b = 7 \):
  - \( \frac{100}{49} \approx 2.04 \), \( \log_2 2.04 \approx 1.03 \), \( a_{\text{max}} = 1 \)
  - \( a = 1 \): \( X = 2 \times 49 = 98 \)
  - 個数: 1

総和: 6 + 3 + 2 + 1 = 12

実際に列挙すると：

- \( b=1 \): 2, 4, 8, 16, 32, 64
- \( b=3 \): 18, 36, 72
- \( b=5 \): 50, 100
- \( b=7 \): 98

合計 12個。これらはすべて異なり、かつ \( N = 100 \) 以下の良い整数を網羅しています。

### 一般の \( N \) に対する解法

以上の考察から、以下の手順で良い整数の個数を計算できます：

1. \( b_{\text{max}} = \lfloor \sqrt{N} \rfloor \) を計算。なぜなら、\( b^2 \leq N \) が必要。
2. \( b \) を 1 から \( b_{\text{max}} \) まで動かし、以下の条件を満たす \( b \) を選ぶ：
   - \( b \) は square-free。
   - \( b \) は奇数。
3. 各 \( b \) に対して：
   - \( \frac{N}{b^2} \geq 2 \) の場合：
     - \( a_{\text{max}} = \lfloor \log_2 (N / b^2) \rfloor \)
     - \( a \) の個数は \( a_{\text{max}} \)
   - \( \frac{N}{b^2} < 2 \) の場合：
     - \( a \) の個数は 0
4. すべての該当する \( b \) について \( a \) の個数を合計する。

### 実装の注意点

- square-free の判定：\( b \) を素因数分解し、すべての素数の指数が1以下であることを確認。
- \( \log_2 \) の計算：数学的には \( \log_2 x = \frac{\ln x}{\ln 2} \) で計算できるが、プログラムでは整数演算で \( 2^k \leq x \) となる最大の \( k \) を求める方が正確。
- \( b \) の範囲：\( b^2 \leq N \) だが、\( 2^a \times b^2 \leq N \) かつ \( a \geq 1 \) より \( b^2 \leq N/2 \) なので、\( b \leq \lfloor \sqrt{N/2} \rfloor \)。

### 最終的なアルゴリズム

1. \( b_{\text{max}} = \lfloor \sqrt{N / 2} \rfloor \)
2. \( \text{count} = 0 \)
3. For \( b \) from 1 to \( b_{\text{max}} \):
   - If \( b \) is square-free and odd:
     - \( x = N / b^2 \)
     - If \( x \geq 2 \):
       - Find the largest integer \( a \) such that \( 2^a \leq x \)
       - \( \text{count} += a \)
4. Return \( \text{count} \)

### 計算量

- \( b \) の範囲は \( O(\sqrt{N}) \)。
- 各 \( b \) に対して square-free のチェックは \( O(\sqrt{b}) \) （素因数分解による）。
- 全体で \( O(N^{3/4}) \) 程度になるが、\( N \) が大きい場合には効率化が必要になる可能性がある。

### 例：\( N = 10 \)

\( b_{\text{max}} = \lfloor \sqrt{10 / 2} \rfloor = \lfloor \sqrt{5} \rfloor = 2 \)

square-free な奇数 \( b \): 1

- \( b = 1 \):
  - \( x = 10 / 1 = 10 \)
  - \( a_{\text{max}} = \lfloor \log_2 10 \rfloor = 3 \) （\( 2^3 = 8 \leq 10 \), \( 2^4 = 16 > 10 \)）
  - \( a = 1, 2, 3 \): \( X = 2, 4, 8 \)
  - 個数: 3

良い整数: 2, 4, 8 → 3個

### 例：\( N = 400 \)

\( b_{\text{max}} = \lfloor \sqrt{400 / 2} \rfloor = \lfloor \sqrt{200} \rfloor = 14 \) （\( 14^2 = 196 \leq 200 \), \( 15^2 = 225 > 200 \)）

square-free な奇数 \( b \leq 14 \): 1, 3, 5, 7, 11, 13

- \( b = 1 \):
  - \( x = 400 / 1 = 400 \)
  - \( \log_2 400 \approx 8.644 \), \( a_{\text{max}} = 8 \)
  - 個数: 8
- \( b = 3 \):
  - \( x = 400 / 9 \approx 44.44 \)
  - \( \log_2 44.44 \approx 5.47 \), \( a_{\text{max}} = 5 \)
  - 個数: 5
- \( b = 5 \):
  - \( x = 400 / 25 = 16 \)
  - \( \log_2 16 = 4 \), \( a_{\text{max}} = 4 \)
  - 個数: 4
- \( b = 7 \):
  - \( x = 400 / 49 \approx 8.163 \)
  - \( \log_2 8.163 \approx 3.03 \), \( a_{\text{max}} = 3 \)
  - 個数: 3
- \( b = 11 \):
  - \( x = 400 / 121 \approx 3.306 \)
  - \( \log_2 3.306 \approx 1.72 \), \( a_{\text{max}} = 1 \)
  - 個数: 1
- \( b = 13 \):
  - \( x = 400 / 169 \approx 2.366 \)
  - \( \log_2 2.366 \approx 1.24 \), \( a_{\text{max}} = 1 \)
  - 個数: 1

総和: 8 + 5 + 4 + 3 + 1 + 1 = 22

### 結論

与えられた正の整数 \( N \) に対して、1以上 \( N \) 以下の良い整数の個数を求めるには、以下の手順を実行します：

1. \( b_{\text{max}} = \lfloor \sqrt{N / 2} \rfloor \) を計算。
2. \( b = 1 \) から \( b_{\text{max}} \) まで、\( b \) が square-free かつ奇数のものを選ぶ。
3. 各 \( b \) に対して：
   - \( x = N / b^2 \)
   - \( x \geq 2 \) の場合、\( a_{\text{max}} = \lfloor \log_2 x \rfloor \) を計算。
   - \( a_{\text{max}} \) を個数に加算。
4. すべての該当する \( b \) について個数を合計したものが答え。

### 実装例（擬似コード）

```python
import math

def is_square_free(b):
    if b == 1:
        return True
    # Check for square factors
    for d in range(2, int(math.sqrt(b)) + 1):
        if b % (d * d) == 0:
            return False
    return True

def count_good_integers(N):
    count = 0
    b_max = int(math.isqrt(N // 2))
    for b in range(1, b_max + 1):
        if b % 2 == 1 and is_square_free(b):
            x = N // (b * b)
            if x >= 2:
                a_max = x.bit_length() - 1  # Equivalent to floor(log2(x))
                count += a_max
    return count
```

### 最終回答

与えられた正の整数 \( N \) に対して、1以上 \( N \) 以下の「良い整数」の個数は、以下の手順で求められます：

1. \( b \) を、square-free（平方因子を持たない）かつ奇数の正の整数とする。
2. \( b \) を \( 1 \) から \( \lfloor \sqrt{N / 2} \rfloor \) までの範囲で動かす。
3. 各 \( b \) に対して、\( 2^a \times b^2 \leq N \) を満たす最大の \( a \geq 1 \) を見つけ、その \( a \) の個数を求める。
   - \( a_{\text{max}} = \lfloor \log_2 (N / b^2) \rfloor \)
4. すべての該当する \( b \) について \( a_{\text{max}} \) を合計した値が良い整数の個数。

この方法により、効率的に良い整数の個数を計算することができます。
